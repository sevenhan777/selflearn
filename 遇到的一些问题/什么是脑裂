一个集群中，有多个节点，对外写服务只有一个节点，就是主节点，其余为从节点，所有数据都是由主节点同步给从节点，当主从节点之间的网络连接点开后，就会各自认为自己是主节点而同时对外部提供服务导致
数据不一致，这个就是脑裂

总结：
1. 主节点定时发送消息给从节点，从节点通过是否收到消息超时来判断主节点是否存活
2. 一个节点发现主节点发送消息超时，则把自己变成candidate,并修改任期（原任期term+1），并广播到其他节点发起投票
3. 其他节点收到投票消息后，
      a.先确认candidate的任期，一个任期follower只能投一票，低于任期的candidate不会被投票，
      b.看日志，candidate 的日志最新 则给他投票
4. 投票后，获得一半节点以上的投票成为新的leader

详解：
解决脑裂：raft 算法
什么是 Raft 共识算法
Raft 是一个具体实现 Quorum 原理的 强一致性分布式共识协议，它的目标是：

在一个集群中，即使部分节点宕机，依然能保证数据一致性、领导者唯一性、顺序一致性。

✅ Raft 的核心机制
Raft 将节点分为三种状态：

状态	描述
Follower	默认状态，响应 Leader 或候选人的请求
Candidate	在选主阶段争夺 Leader 的角色
Leader	唯一能对外提供写服务的节点

🗳️ 1. Leader 选举
当 Follower 超时未收到心跳，就发起投票，成为 Candidate。
Candidate 请求其他节点投票（包含当前任期号）。
获得 多数投票 后成为 Leader。

✅ Raft 的 Leader 总是唯一的，因为：
任期（term）单调递增
每个节点每任期只能投一次票

📦 2. 日志复制机制（数据一致性）
写入数据的流程：
客户端发写请求给 Leader。
Leader 将日志条目发送给所有 Follower。
当多数 Follower 写入成功后，Leader 才认为该操作 提交成功。
然后通知 Follower 应用该操作。
📌 只有 Leader 能接收写入，避免了数据冲突。

🔄 3. 网络分区场景（脑裂防护）
假设一个 5 节点集群：
网络断裂成两组：2 个节点和 3 个节点
少数派的 2 个节点无法选出 Leader，无法写入
多数派的 3 个节点继续选主、接受写入
数据始终只在“合法”的一半上更新
✅ 这就是 quorum 保护 + raft 一致性 的组合优势。

例子：
场景设定
一个 Raft 集群有 5 个节点，分别叫：
A、B、C、D、E
它们一开始都是 Follower。
💥 事件发生：假设 Leader 宕机了
节点 A 原本是 Leader，但突然宕机，其他节点收不到心跳（心跳是 Leader 定期发给 Follower 的信号）。
⏱️ 超时后：Follower 变 Candidate，发起选举
比如节点 B 的定时器先超时：
B 自己变成 Candidate
将当前 term 增加：term = 2（假设上一任 Leader 是 term 1）
向其他节点广播请求投票（RequestVote）
📮 其他节点如何回应？
每个 Follower：
会记录当前任期号
如果本轮投票还没投过票，并且请求的 Candidate 的日志“新”，就会投票
假设结果如下：
B 请求：term = 2
B 给自己投票 ✅
C、D 都同意 B，投票给 B ✅
E 的网络比较慢，没收到或投票给别人 ❌
✳️ B 获得了 3 张票（B、C、D），占 5 个节点中的多数（> 5/2）
👉 B 成为新的 Leader（term 2）
✅为什么不会出现两个 Leader？
因为一个节点在一个 term 内只投一次票。
如果 B 成为 Leader 后，E 后来超时也发起投票，想当 Leader：
它只能在 term 3 发起选举（因为 term 单调递增）。
但如果大多数节点（比如 B、C、D）已经在 term 2 投过票了，
它们不会投票给 term 2 以下的 Candidate。
📌 所以最终只会有一个 Leader 成功拿到多数票！
🧠 一句话总结选举规则：
每个节点在一个 term 中 最多只能投一次票
节点之间用 term 来判断“谁更新”
大多数投票决定唯一的 Leader
如果投票被分裂（没有超过半数），没人当选，重新进入下一轮（term + 1）

问题1 这个任期term是咋回事
举个例子来说明这句话：
初始状态：
你有 5 个节点：A、B、C、D、E
A 是旧 Leader，它挂了
所有节点当前任期为 1
Step 1：B 先超时，发起选举（term = 2）
B 变成 Candidate，开始选举
它发送 RequestVote(term=2) 给其他节点
B、C、D 都在 term 2 给 B 投了票
✅ B 票数：3，成为新 Leader
此时 B、C、D 的 currentTerm = 2，votedFor = B
Step 2：E 网络慢，过了一会儿也超时了，发起选举（term = 1）
E 以为自己还在 term 1（或没收到 term 2 的消息）
E 向 B、C、D 发投票请求（RequestVote(term=1)）
现在就会发生这句话的情况：
B、C、D 都已经是 term=2，比 E 的 term=1 新，它们会直接拒绝投票。
因为 raft 的机制里规定：
不能投给旧任期
一个 term 内不能投两次
所以：
✅ E 的选举失败，因为它根本得不到多数节点的投票。
✅ 总结这句话：
B、C、D 已经在 term 2 投了票（给了 B），所以它们不会再响应 term=1 的投票请求。
📌 防止脑裂、双主、重复投票的关键机制就在这里！

问题2 最新日志机制是啥
每个节点投票给谁，依据什么？
在 Raft 的 Leader 选举过程中，每个 Follower 节点在一个任期（term）中只能投一次票，投票给某个发起选举的 Candidate。投还是不投、投给谁，是由以下几个条件决定的：
✅ 主要依据有两个：
1. Candidate 的日志是否“最新”
2. 自己这一轮是否已经投过票
🔍 详细说明这两个条件：
🔸 条件一：是否已投票
每个 Follower 在一个 term 中只能投一次票
如果已经投了票，就不能再给别的 Candidate 投票了
如果我在 term=3 投票给了 B，
再有人来请求投票（哪怕更“新”），我也不能再投。
🔸 条件二：日志是否“更新”
Follower 只会投票给日志“最新”的 Candidate
Raft 定义“日志更新”的规则如下：
规则	对比
先比日志的最后一个日志条目的 term	
如果 term 相同，再比日志条目的 index（长度）	
优先级：
logTerm 高 → 更新                        logTerm = 最后一条日志所带的任期编号
logTerm 相等 → logIndex 长 → 更新
否则 → 不投票
✅ 这防止了“数据落后的节点”成为 Leader。

想到的一些问题：
1. 没有考虑节点间的性能差异
2. 受网络延迟影响较大
3. 单节点对外提供写，以及同步给多数节点后才能写完成性能差
4. 节点成为candidate前是不是应该判断一下，是不是自己的网络出了问题，避免不必要的广播
