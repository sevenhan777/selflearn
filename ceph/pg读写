什么是pg
pg的数据读写流程
一个pg的多副本一致性问题
pg如何在osd间迁移，进而实现数据恢复和数据平衡

=======================================================================================================================================================
概念：
peering:
当集群发生变动（如新增/下线 OSD、重启、网络分区等），PG 中的数据副本可能分布在不同 OSD 上。这时候 Ceph 需要重新协调这些副本，
以找出哪一个副本是最新的、哪些副本需要同步，这一过程就叫 Peering（对等协商）
什么是 PG Peering？
Peering 是一个 分布式一致性协议过程，目的是让同一个 PG 的多个副本（OSD 上的）彼此“对齐”，达成一致的视图。

在 peering 过程中，每个参与副本会报告自己所拥有的 PG 的最新状态（日志、版本号、对象列表等），主 OSD（acting primary）基于这些信息决定：

哪些对象是最新的；

哪些副本需要进行恢复（recovery）或重同步（backfill）；

是否可以进入 active+clean 状态（即可对外提供服务）。

🔄 为什么需要 Peering？
因为 Ceph 是一个高度分布式系统，PG 的副本分布在多个 OSD 上，而这些副本之间可能出现以下情况：

某个 OSD 崩溃又重启，数据是否丢失？

OSDMap 变更，PG 被迁移到了其他 OSD；

有写入操作在某些副本成功，其他副本失败；

网络分区时，PG 状态可能不一致。

为了保证这些情况之后，集群仍然是强一致性的，必须进行一次 peering 来 协商“哪个是正确的 PG 状态”。

📌 Peering 触发的典型场景：
OSD 启动或重启；

OSD 崩溃或下线；

集群新增或移除 OSD；

OSDMap 更新（比如 crush map 变化）；

重新平衡（rebalance）发生；

整个集群重启。
》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》
osd map:
OSD Map 是一个由 Monitor 维护的、描述集群拓扑和 OSD 状态的映射表，包含了所有 OSD 的健康状态、PG 到 OSD 的映射规则等关键信息。

✅ OSD Map 包含哪些信息？
信息项	说明
所有 OSD 的 ID 和状态	包括每个 OSD 是否 up/down，in/out
CRUSH 映射	用于数据分布的规则（包括权重等）
PG 到 OSD 的映射	每个 PG 应该由哪些 OSD 存储副本
版本号（epoch）	每次变动都加一，确保有序更新
Pool 信息	包括 Pool 数量、PG 数量、副本数等
历史事件（如 OSD 添加）	帮助恢复时回溯状态变化

✅ 它是干嘛用的？
客户端基于 OSD Map + CRUSH 算法可以定位对象在哪个 OSD 上（无须中心路由）；

OSD 之间通过它协调 PG 所属、副本副本一致性等；

用于 PG peering、数据恢复、迁移等重要流程；

保证集群一致性和故障恢复的关键。

✅ 举个简单例子：
假设你有：

4 个 OSD：ID 为 0~3；

有一个 Pool 设置为 64 个 PG，每个 PG 保持 2 个副本；

OSD Map 会告诉你：

OSD.2 当前是 down 状态；

PG 3 的副本在 OSD.0 和 OSD.2；

PG 3 需要恢复一个副本到 OSD.1，因为 OSD.2 down；

OSD.1 目前 in，且有足够空间；

客户端查询对象 hash 为 PG 3，根据 OSD Map 得知应联系 OSD.0 读取。

》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》
一个pg中有哪些不同的对象：
head 对象：当前最新版本的数据对象；

clone 对象：表示某个快照时刻的历史数据副本（实际存储了当时的对象数据）；

snapdir 对象：用于管理一个对象的快照信息元数据（不包含实际数据）。

🔄 具体分工：
类型	内容	作用
head	当前对象的最新数据	普通读写操作针对的对象
clone	每个快照时刻的对象副本	保留对象的历史数据（可以通过快照访问）
snapdir	快照列表 + clone 映射信息	记录有哪些快照、每个快照指向哪个 clone

🔍 举个例子：
你对对象 foo 打了两个快照 snap1 和 snap2，然后继续修改对象内容。

那么 Ceph 会：

把 snap1 和 snap2 时刻的对象内容分别拷贝成两个 clone（如 foo@snap1, foo@snap2）；

把这两个 clone 的元信息（它们属于哪个快照，时间戳等）写入 foo~snapdir 对象中；

继续的写操作只影响 foo（head 对象）本身，不会影响 clone。

✅ 为什么要分开存？
clone 存数据：因为快照要支持读历史数据，必须保存当时的数据版本；

snapdir 存元数据：集中管理 clone 的映射关系、快照 ID、时间戳等，方便快照遍历和恢复。

》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》
omap 用来干什么？
OMAP 主要用于存储对象的元数据，常见的用途有：

用途	示例说明
RADOSGW 元数据存储	比如 S3 的 object tag、ACL、versioning 信息等
RBD 镜像元数据	RBD 镜像快照、层结构、映射关系
CephFS 的 inode 信息	存储 inode 对象的属性（如权限、时间戳等）
Bluestore 自身内部管理用途	记录对象状态、回滚信息等

》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》
pg 读写流程
1 ）OSD 收到客户端发送的读写请求，将其封装为一个 op 并基于其携带的 PGID 转 发至相应的 PGO 

2 ）PG 收到 op 后，完成一系列检查，所有条件均满足后，开始真正执行 op。

3 ）如果 op 只包含读操作，那么直接执行同步读（对应多副本）或者异步读（对应纠 删码）， 等待读操作完成后向客户端应答。 

4 ）如果 op 包含写操作，首先由 Primary 基于 op 生成一个针对原始对象操作的事务
及相关日志，然后将其提交至 PGBackend, 由 PGBackend 按照备份策略转化为每个 PG
实例（包含 Primary 和所有 Replica）真正需要执行的本地事务并进行分发，当 Primary 收到所有副本的写入完成应答之后，
对应的 op 执行完成，此时由 Primary 向客户端回应 写入完成

》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》
