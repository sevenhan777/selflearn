背景：
传统集中式存储，有中心节点，可以在中心节点上控制IO流量，ceph 去中心化，数据直接与osd 交互无法像集中式存储那样，在一个中心点进行流控
比较合理的方式是 为每一个osd 做qos.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MCLOCK:
https://zhuanlan.zhihu.com/p/38405926
https://juejin.cn/post/6844904015856140301
 背景设置：
客户端 A（Client A）的最小调度粒度为 q = 2，也就是说，它希望每 2ms 处理一个请求；

当前时间是 10ms；

使用的时间戳公式是：
R(r,i) = max{ R(r-1,i) + 1/ri, Current time} // R(r,i) 表示到达VMi的第r个请求
所以每个请求的预定时间应该间隔 2ms。

🧮 请求时间戳计算：
请求编号	上一个时间戳 Q_{i,j-1}	当前时间戳 Q_{i,j}	当前时间 (now)	可否进入 Reservation
1	-（假设为 0）	max(0 + 1/0.5, 10) = max(2, 10) = 10	10	✅ 是，正好匹配
2	10	max(10 + 2, 10) = 12	10	❌ 不能，时间未到

🚨 情况说明：
第一个请求时间戳是 10，当前时间是 10，满足 Reservation 要求，立即调度。

第二个请求时间戳是 12，但当前时间还是 10，还没到预约时间，不能在 Reservation 阶段调度，因此会进入 Weight 阶段。

这里即出现了“滑落”：从预约调度阶段滑入权重调度阶段。

🔁 为什么要“回调时间戳”？
假设我们不调整时间戳，继续往下：

第三个请求会计算时间戳为 Q_3 = max(12 + 2, now) = 14；

当前时间可能还只是 11 或 12，第三个请求依然不满足 Reservation 阶段条件；

如果持续这样，就会陷入：所有请求都进入 Weight 阶段，Reservation 机制形同虚设！

为了解决这个问题 —— 第二个请求既然在 Weight 阶段被提前处理了，它的预约窗口等于“浪费”了，所以我们就：

回调第三个请求的时间戳，减少一个步长（如 -1），填补第二个请求“跳过”的预约时间窗口。

这样可以让后面的请求更有可能在 Reservation 阶段成功调度，避免过度落入 Weight 阶段，保持 QoS 的平稳性。

